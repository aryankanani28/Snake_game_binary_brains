#include <iostream>
#include <ncurses.h>
#include <vector>
#include <cstdlib>
#include <ctime>

using namespace std;

class Point {
public:
    int x, y;
    Point(int x = 0, int y = 0) : x(x), y(y) {}
};

class SnakeGame {
private:
    int width, height, score;
    vector<Point> snake;
    Point food;
    char direction;
    bool gameOver;

public:
    SnakeGame(int w, int h) : width(w), height(h), score(0), direction('R'), gameOver(false) {
        initializeGame();
    }

    void initializeGame() {
        snake.clear();
        snake.push_back(Point(width / 2, height / 2));
        snake.push_back(Point(width / 2 - 1, height / 2));
        snake.push_back(Point(width / 2 - 2, height / 2));
        generateFood();
        score = 0;
        direction = 'R';
        gameOver = false;
    }

    void generateFood() {
        srand(time(0));
        int fx, fy;
        bool valid;
        do {
            valid = true;
            fx = rand() % (width - 2) + 1;
            fy = rand() % (height - 2) + 1;
            for (auto &s : snake) {
                if (s.x == fx && s.y == fy) {
                    valid = false;
                    break;
                }
            }
        } while (!valid);
        food = Point(fx, fy);
    }

    void processInput() {
        int ch = getch();
        switch (ch) {
            case 'w': case 'W': case KEY_UP: if (direction != 'D') direction = 'U'; break;
            case 's': case 'S': case KEY_DOWN: if (direction != 'U') direction = 'D'; break;
            case 'a': case 'A': case KEY_LEFT: if (direction != 'R') direction = 'L'; break;
            case 'd': case 'D': case KEY_RIGHT: if (direction != 'L') direction = 'R'; break;
            case 'q': gameOver = true; break;
        }
    }

    void update() {
        Point newHead = snake[0];
        switch (direction) {
            case 'U': newHead.y--; break;
            case 'D': newHead.y++; break;
            case 'L': newHead.x--; break;
            case 'R': newHead.x++; break;
        }

        if (newHead.x == 0 || newHead.x == width - 1 || newHead.y == 0 || newHead.y == height - 1) {
            gameOver = true;
            return;
        }

        for (size_t i = 0; i < snake.size(); ++i) {
            if (snake[i].x == newHead.x && snake[i].y == newHead.y) {
                gameOver = true;
                return;
            }
        }

        snake.insert(snake.begin(), newHead);

        if (newHead.x == food.x && newHead.y == food.y) {
            score++;
            generateFood();
        } else {
            snake.pop_back();
        }
    }

    void render() {
        clear();

        for (int i = 0; i < width; ++i) mvprintw(0, i, "*");
        for (int i = 0; i < width; ++i) mvprintw(height - 1, i, "*");
        for (int i = 1; i < height - 1; ++i) mvprintw(i, 0, "|");
        for (int i = 1; i < height - 1; ++i) mvprintw(i, width - 1, "|");

        for (auto &s : snake) mvprintw(s.y, s.x, "O");
        mvprintw(food.y, food.x, "F");
        mvprintw(height, 0, "Score: %d", score);

        refresh();
    }

    bool isGameOver() { return gameOver; }
    int getScore() { return score; }
};

int main() {
    initscr();
    noecho();
    curs_set(0);
    keypad(stdscr, TRUE);
    nodelay(stdscr, TRUE);

    SnakeGame game(40, 20);

    while (true) {
        while (!game.isGameOver()) {
            game.processInput();
            game.update();
            game.render();
            napms(100);
        }

        endwin();
        cout << "Game Over! Final Score: " << game.getScore() << endl;
        cout << "Press 'R' to restart or any other key to exit..." << endl;
        
        char choice;
        cin >> choice;
        if (choice == 'R' || choice == 'r') {
            initscr();
            noecho();
            curs_set(0);
            keypad(stdscr, TRUE);
            nodelay(stdscr, TRUE);
            game = SnakeGame(40, 20);
        } else {
            break;
        }
    }

    endwin();
    return 0;
}
